/* ACSI2STM Atari hard drive emulator
 * Copyright (C) 2019-2021 by Jean-Matthieu Coulon
 *
 * This Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the program.  If not, see <http://www.gnu.org/licenses/>.
 */

#define A1 PB6 // Must be on port B
#define CS PB7 // Must be on port B
#define IRQ PA8
#define DRQ PA11 // Must be on Timer1 channel output
#define ACK PA12 // Must be on Timer1 external clock
// Data pins are on PB8-PB15

// Pin masks for direct port access
#define A1_MASK  0b0000000001000000
#define CS_MASK  0b0000000010000000
#define IRQ_MASK 0b0000000100000000
#define DRQ_MASK 0b0000100000000000
#define ACK_MASK 0b0001000000000000

// Timer
#define DMA_TIMER TIMER1_BASE
#define CS_TIMER TIMER4_BASE

/*
How CS and A1 signals are handled
=================================

Expected behavior
-----------------

CS is generated by the ST, it signals that an IRQ transfer has been executed.
A1 is generated by the ST, when low it signals that the current transfer is
the beginning of a new command.

Command (ST -> STM32)

         ______________         ________        ___
    IRQ                |_______|        |______|
         ___   _____________   _____________   ____
    CS      |_|             |_|             |_|
         __     ___________________________________
    A1     |___|
    
    DATA    [1]             [2]             [3]


Status (STM32 -> ST)

         __         __
    IRQ    |_______|
         _______   ___
    CS          |_|
    
    DATA   [=======]


STM32 implementation
--------------------

Main issues faced in previous versions:

 * The CS pulse is too fast to be reliably polled.
 * A1 and CS must be read at the same time.
 * Data is guaranteed to be available only when the CS pin is low.

In order to sample CS, A1 and D0-D7 pins all at the same time, a hardware
timer and 2 DMA channels are used. In order to sample both CS and A1, the
timer is set in rotating encoder mode.

In encoder mode 2, A1 gives the rotation direction and CS gives the rotation
pulse. A CS pulse is equivalent to rotating the encoder one step in one
direction, then quickly going back to the starting position.

Overview of the setup:
             __________
         DIR|  Timer4  |Underflow
   A1 ----->|TI1       |------------
            |          |            |
        STEP|          |CH3 CC      |
   CS ----->|TI2       |------------+
            |__________|            |
                                    |Trigger (DMA1 CH5+CH7)
                      _______     __V___     __________
                     |       |   |      |   |          |
                     | GPIOB |-->| DMA1 |-->|  Timer4  |
                     |       |   |      |   |  CH4 CC  |
                     |_______|   |______|   |__________|

A CS pulse with A1 low will pulse the timer counter to 1, then back to 0. This
will trigger CH3 compare event.

A CS pulse with A1 high will pulse the timer counter to -1 (65535), then back
to 0. This will trigger the overflow/underflow event.

Both events will trigger a DMA operation that copies GPIOB to the channel 4 CC
value.

Timer4 CH4 is used as a simple buffer because GPIOB is considered as memory by
the STM32 DMA engine and memory to memory copies cannot be triggered by a
timer, so it has to be a memory to peripheral copy. Any unused peripheral
register can be used for this task.


How ACSI DMA is handled (DRQ/ACK pulses and data sampling)
==========================================================

Expected behavior
-----------------

DRQ is generated by the STM32, it triggers a DMA transfer.
ACK is generated by the ST, it tells the STM32 when the data bus is sampled.
DRQ must go high at most 180ns after ACK goes low. Failing to do that will
abort the DMA transfer by the ST.

DMA reads (STM32 -> ST)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|
    
    DATA                        S

Data seems to be sampled when ACK goes up (marked "S").
The STM32 keeps the data up for the whole transfer (DRQ+ACK), which avoids
risks of reading invalid data.


DMA writes (ST -> STM32)

          ___              _________
     DRQ     |____________|
          ______________         ___
     ACK                |_______|
    
    DATA               [========]

Data is guaranteed to be available during the whole ACK pulse (marked "[==]").


STM32 implementation
--------------------

DRQ and ACK pulses are too fast to use bit banging, even with direct port
access.

The current implementation uses STM32 timers and its DMA engine to process
these signals. Data flow:
             __________
         CLK|          |CH4
  ACK ----->|  Timer1  |-----> PA11 (DRQ)
            |          |
            |          |CH3
            |          |------------
            |__________|            |
                                    |Trigger (DMA1 CH6)
                      _______     __V___     __________
                     |       |   |      |   |          |
                     | GPIOB |-->| DMA1 |-->|  Timer1  |
                     |       |   |      |   |  CH1 CC  |
                     |_______|   |______|   |__________|

 * ACK is used as Timer1 clock.
 * PA11 (DRQ) is used as a PWM output that goes up whenever Timer1 receives a clock tick.
 * Timer1 triggers a STM32 DMA transfer whenever Timer1 receives a clock tick.
 * The STM32 DMA engine copies GPIOB to Timer1 CH1 compare value.
 * Timer1 CH1 is used as a simple buffer because GPIOB is considered as memory
   by the STM32 DMA engine and memory to memory copies cannot be triggered by
   a timer, so it has to be a memory to peripheral copy. Any unused peripheral
   register can be used for this task.
 * If multiple ACK signals are received, this can be detected by having an incorrect
   counter value. This avoids silent data corruption in case of problems. This check is
   only done if ACSI_CAREFUL_DMA is enabled.


DMA read process
----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte read process:

 * Data is put on the data bus.
 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Wait until ACK goes high.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1


DMA write process
-----------------

DMA block transfer initialization process:

 * Set Timer1 counter to a high value so DRQ will be high when enabled
 * Enable DRQ in PWM mode (high if Timer1 > 0, low if Timer1 = 0)
 * Enable Timer1

DMA byte write process:

 * Set Timer1 counter to 0, this will pull DRQ low.
 * When ACK goes low, Timer1 counts to 1.
 * Timer1 counting will set DRQ high.
 * Timer1 counting will trigger the STM32 DMA CH6.
 * The STM32 DMA will copy GPIOB to Timer1 CH1 compare value.
 * Wait until ACK goes high.
 * Read Timer1 CH1 compare value to get the data byte.

DMA block transfer stop process:

 * Set DRQ pin as input
 * Disable Timer1

*/

#include "acsi2stm.h"
#include "Debug.h"
#include "Acsi.h"
#include <libmaple/dma.h>

#ifdef ACSI_ACTIVITY_LED
static inline void ledOn() {
  GPIOC->regs->BSRR = 1 << (13 + 16);
}
static inline void ledOff() {
  GPIOC->regs->BSRR = 1 << 13;
}
static inline void ledInit() {
  pinMode(PC13, OUTPUT);
  ledOn();
}
#else
static inline void ledOn() {
}
static inline void ledOff() {
}
static inline void ledInit() {
}
#endif

void DmaPort::begin(uint8_t mask) {
  // Initialize the watchdog timer
  watchdog.begin();

  deviceMask = mask;
  init();
}

void DmaPort::init() {
  ledInit();
  dma_init(DMA1);
  setupDrqTimer();
  setupCsTimer();
  setupGpio();
}

bool DmaPort::idle() {
  return 
    ((GPIOA->regs->IDR & (IRQ_MASK | DRQ_MASK | ACK_MASK)) == IRQ_MASK | DRQ_MASK | ACK_MASK)
    && ((GPIOB->regs->IDR & (A1_MASK | CS_MASK)) == (A1_MASK | CS_MASK));
}

void DmaPort::waitBusReady() {
  watchdog.pause();

  pinMode(CS, INPUT_PULLDOWN);
  pinMode(A1, INPUT_PULLDOWN);
  delay(10);

  for(int idleTime = 0; idleTime < 100; ++idleTime) {
    // Blink the LED fast
    if((millis() & 0xff) > 0x80)
      ledOn();
    else
      ledOff();

    delayMicroseconds(300);
    if(!idle())
      idleTime = 0;
  }

  CS_TIMER->CNT = 0;

  pinMode(CS, INPUT);
  pinMode(A1, INPUT);

  ledOff();

  watchdog.resume();
}

uint8_t DmaPort::waitCommand() {
  uint8_t byte;

  watchdog.pause();
  ledOff();

  do {
    byte = waitA1(); // Read the 1st command byte
  } while(!((1 << (byte >> 5)) & deviceMask)); // Check the device ID

  watchdog.resume();
  while(!idle());
  ledOn();

  acsiVerbose("[+");
  acsiVerbose(byte, HEX);
  acsiVerbose(']');

  return byte;
}

void DmaPort::readIrq(uint8_t *bytes, int count) {
  // Disable systick that introduces jitter.
  systick_disable();

  while(count > 0) {
    *bytes = readIrq();
    ++bytes;
    --count;
  }

  // Restore systick
  systick_enable();
}

uint8_t DmaPort::readIrq() {
  acsiVerbose("[<");

  pullIrq();
  uint8_t byte = waitCs(); // Wait CS pulse and read data
  releaseIrq();

  acsiVerbose(byte,HEX);
  acsiVerbose(']');

  return byte;
}

void DmaPort::sendIrq(uint8_t byte) {
  acsiVerbose("[>");
  acsiVerbose(byte,HEX);
  acsiVerboseln(']');

  // Disable systick that introduces jitter.
  systick_disable();

  acquireDataBus();
  writeData(byte);
  pullIrq();
  waitCs();

  releaseIrq();
  releaseDataBus();

  // If CS never goes up before the watchdog triggers, the cable is probably disconnected.
  while(!idle());

  // Restore systick
  systick_enable();
}

void DmaPort::read(uint8_t *bytes, int count) {
  // Disable systick that introduces jitter.
  systick_disable();

  acsiVerbose("DMA read ");

#if ACSI_ACK_FILTER
  // Enable ACK filter/delay
  ACSI_TIMER->SMCR = (ACSI_TIMER->SMCR & ~(0xf << 8)) | ((ACSI_ACK_FILTER) << 8);
#endif

  acquireDrq();

  // Unroll for speed
  int i;
  for(i = 0; i <= count - 16; i += 16) {
#define DMA_READ_BYTE(b) do { \
      DMA_TIMER->CNT = 0; \
      while(DMA_TIMER->CNT == 0); \
      bytes[b] = (uint8_t)(DMA_TIMER->CCR1 >> 8); \
    } while(0)
    DMA_READ_BYTE(0);
    DMA_READ_BYTE(1);
    DMA_READ_BYTE(2);
    DMA_READ_BYTE(3);
    DMA_READ_BYTE(4);
    DMA_READ_BYTE(5);
    DMA_READ_BYTE(6);
    DMA_READ_BYTE(7);
    DMA_READ_BYTE(8);
    DMA_READ_BYTE(9);
    DMA_READ_BYTE(10);
    DMA_READ_BYTE(11);
    DMA_READ_BYTE(12);
    DMA_READ_BYTE(13);
    DMA_READ_BYTE(14);
    DMA_READ_BYTE(15);
    bytes += 16;
  }

  while(i < count) {
    DMA_READ_BYTE(0);
    ++i;
    ++bytes;
  }

#undef DMA_READ_BYTE

  releaseDrq();

#if ACSI_ACK_FILTER
  // Disable ACK filter/delay
  ACSI_TIMER->SMCR = (ACSI_TIMER->SMCR & ~(0xf << 8));
#endif

  // Restore systick
  systick_enable();

  acsiVerboseDump(&bytes[-i], i);
  acsiVerboseln(" OK");
}

void DmaPort::send(const uint8_t *bytes, int count) {
  acsiVerbose("DMA send ");
  acsiVerboseDump(&bytes[0], count);

  // Disable systick that introduces jitter.
  systick_disable();

  acquireDataBus();
  acquireDrq();

  // Unroll for speed
  int i;
  for(i = 0; i <= count - 16; i += 16) {
#define DMA_SEND_BYTE(b) do { \
      writeData(bytes[b]); \
      DMA_TIMER->CNT = 0; \
      while(DMA_TIMER->CNT == 0); \
    } while(0)
    DMA_SEND_BYTE(0);
    DMA_SEND_BYTE(1);
    DMA_SEND_BYTE(2);
    DMA_SEND_BYTE(3);
    DMA_SEND_BYTE(4);
    DMA_SEND_BYTE(5);
    DMA_SEND_BYTE(6);
    DMA_SEND_BYTE(7);
    DMA_SEND_BYTE(8);
    DMA_SEND_BYTE(9);
    DMA_SEND_BYTE(10);
    DMA_SEND_BYTE(11);
    DMA_SEND_BYTE(12);
    DMA_SEND_BYTE(13);
    DMA_SEND_BYTE(14);
    DMA_SEND_BYTE(15);
    bytes += 16;
  }

  while(i < count) {
    DMA_SEND_BYTE(0);
    ++i;
    ++bytes;
  }

#undef DMA_SEND_BYTE
  releaseDrq();
  releaseDataBus();

  // Restore systick
  systick_enable();

  acsiVerboseln(" OK");
}

void DmaPort::releaseDrq() {
  GPIOA->regs->CRH = 0x44444BB4; // Set IRQ and DRQ as inputs
}

void DmaPort::releaseIrq() {
  GPIOA->regs->ODR |= IRQ_MASK; // Fast pull up IRQ before releasing
  GPIOA->regs->CRH = 0x44444BB4; // Set IRQ and DRQ as inputs
}

void DmaPort::releaseDataBus() {
  GPIOB->regs->CRH = 0x44444444; // Set PORTB[8:15] to input
}

void DmaPort::acquireDrq() {
  // Set DRQ to high using timer PWM
  TIMER1_BASE->CNT = 2;

  // Transition through input pullup to avoid a hardware glitch
  GPIOA->regs->CRH = 0x44448BB4;

  // Enable timer PWM output to DRQ
  GPIOA->regs->CRH = 0x4444BBB4;
}

void DmaPort::acquireDataBus() {
  GPIOB->regs->CRH = 0x33333333; // Set PORTB[8:15] to 50MHz push-pull output
}

uint8_t DmaPort::waitCs() {
  CS_TIMER->SR &= ~TIMER_SR_UIF;
  while(!(CS_TIMER->SR & TIMER_SR_UIF));
  return (CS_TIMER->CCR4) >> 8;
}

uint8_t DmaPort::waitA1() {
  CS_TIMER->SR &= ~TIMER_SR_CC3IF;
  while(!(CS_TIMER->SR & TIMER_SR_CC3IF));
  return (CS_TIMER->CCR4) >> 8;
}

bool DmaPort::readAck() {
  return GPIOA->regs->IDR & ACK_MASK;
}

void DmaPort::pullIrq() {
  GPIOA->regs->ODR &= ~IRQ_MASK; // Set IRQ to 0
  GPIOA->regs->CRH = 0x44444BB3;
}

void DmaPort::writeData(uint8_t byte) {
  GPIOB->regs->ODR = ((int)byte) << 8;
}

void DmaPort::setupDrqTimer() {
  DMA_TIMER->CR1 = TIMER_CR1_OPM;
  DMA_TIMER->CR2 = 0;
  // Count on DMA ACK pulse
  DMA_TIMER->SMCR = TIMER_SMCR_ETP | TIMER_SMCR_TS_ETRF | TIMER_SMCR_SMS_EXTERNAL;
  DMA_TIMER->PSC = 0; // Prescaler
  DMA_TIMER->ARR = 65535; // Overflow
  DMA_TIMER->DIER = TIMER_DIER_CC3DE; // Trigger DMA
  DMA_TIMER->CCMR1 = 0;
  DMA_TIMER->CCMR2 = TIMER_CCMR2_OC4M;
  DMA_TIMER->CCER = TIMER_CCER_CC4E; // Enable output on DRQ
  DMA_TIMER->EGR = TIMER_EGR_UG; // Update the timer
  DMA_TIMER->CCR2 = 65535; // Disable unused CC channel
  DMA_TIMER->CCR3 = 1; // Compare value
  DMA_TIMER->CCR4 = 1; // Compare value
  DMA_TIMER->CNT = 2;
  DMA_TIMER->CR1 |= TIMER_CR1_CEN;

  // Setup DMA channel 6 to copy GPIOB to timer 1 CH1 compare value
  dma_setup_transfer(DMA1,
                     DMA_CH6,
                     &(DMA_TIMER->CCR1),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH6, 1);
  dma_enable(DMA1, DMA_CH6);
}

void DmaPort::setupCsTimer() {
  CS_TIMER->CR1 = TIMER_CR1_URS;
  CS_TIMER->SMCR = TIMER_SMCR_SMS_ENCODER2;
  CS_TIMER->CCMR1 = TIMER_CCMR1_CC1S_INPUT_TI1
                    | TIMER_CCMR1_CC2S_INPUT_TI2
                    | ((ACSI_CS_FILTER) << 4);
  CS_TIMER->CCMR2 = TIMER_CCMR2_OC3M;
  CS_TIMER->CCER |= TIMER_CCER_CC1P | TIMER_CCER_CC2P;
  CS_TIMER->PSC = 0;
  CS_TIMER->ARR = 65535;
  CS_TIMER->DIER = TIMER_DIER_CC3DE | TIMER_DIER_UDE;
  CS_TIMER->CCR1 = 0;
  CS_TIMER->CCR2 = 0;
  CS_TIMER->CCR3 = 1; // Detects A1
  CS_TIMER->CCR4 = 0; // Receives PORTB on CS pulse
  CS_TIMER->EGR |= TIMER_EGR_UG; // Update the timer
  CS_TIMER->CR1 |= TIMER_CR1_CEN; // Enable the timer
  CS_TIMER->CNT = 0;

  // Setup DMA CH5 & CH7 to copy PORTB to CCR4 on CS pulse
  dma_setup_transfer(DMA1,
                     DMA_CH5,
                     &(CS_TIMER->CCR4),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH5, 1);
  dma_enable(DMA1, DMA_CH5);
  dma_setup_transfer(DMA1,
                     DMA_CH7,
                     &(CS_TIMER->CCR4),
                     DMA_SIZE_16BITS,
                     &(GPIOB->regs->IDR),
                     DMA_SIZE_16BITS,
                     DMA_FROM_MEM | DMA_CIRC_MODE);
  dma_set_num_transfers(DMA1, DMA_CH7, 1);
  dma_enable(DMA1, DMA_CH7);
}

void DmaPort::setupGpio() {
  GPIOA->regs->ODR |= DRQ_MASK;
  releaseDataBus();
  releaseIrq();
  releaseDrq();
}

// vim: ts=2 sw=2 sts=2 et
